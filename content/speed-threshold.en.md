---
title: "Watching, Not Waiting: When AI Coding Crossed the Speed Threshold"
slug: "speed-threshold"
date: 2025-12-03
---

I know that feedback about using AI as a dev is so mid-2025, but I feel there are still some things to say.

I just built a query builder interface in ~2 days - 5k lines of code, complex UI, not a small chunk of work. It's a playground where users can build queries across multiple data sources with advanced filters. Think simplified Metabase. Good candidate for AI assistance, as I knew where I wanted to land, and part of the work was a copycat of what we already do elsewhere.

Without AI, this would have taken me ~6 days. So yes, 3x faster. But that's not what matters here. Everyone has 3x stories by now.

What matters is that something fundamental shifted about how development feels.

## It's So Damn Fast

Days where I start an agent with a prompt and go make myself a cup of coffee or wander on the interwebs are gone.

Simple fix? Couple of seconds. Complex plan execution? 10-20 seconds max. Most of the time, it barely takes 10 or 20 seconds for Cursor with Composer-1 to write any code.

It isn't just about being faster; it is now fast enough to avoid disrupting your flow.

I noticed Cursor's speed improvement with Composer-1 a few weeks ago, but this was my first big feature with it. The difference: now I watch Cursor's thought process instead of waiting for it to be done and reading thoughts afterwards. I stay in the problem mentally.

## It's So Damn Good

Yes, sometimes I had to go fix tiny issues myself because it wasn't able to after several iterations. But on whole features it happened only ~5 times across 5k lines.

One was a positioning issue for a dropdown - turns out the third-party component had an option I found myself. Another was an error in our MobX state management. The console errors weren't helpful, so I switched to console.log debugging.

But here's the surprise: the generated code is clean enough so Cursor itself is able to maintain it, fix bugs, and refactor it when needed.

Not that long ago, after several prompts the code needed manual cleanup, otherwise the agent started getting lost. These times are gone.

## The Code That Maintains Itself

Cursor has a tendency to make big React components and duplicate code like TailwindCSS classes. Traditionally, this would be "bad" code. But during feature implementation, it's more than okay to start simple. At the end, you ask Cursor to refactor by making smaller components - and Cursor is good at it.

When I look at the code generated by Cursor, I could believe I wrote it myself. Not because it's fancy, but because it's straightforward.

This straightforwardness is the key. "Explicit and duplicative" beats "DRY and abstract" when the AI needs to understand and modify it later. Temporary mess that can be auto-refactored in 15 seconds beats premature abstraction.

## Practical Notes

**Conversation management:** I started a new conversation for each new chunk of work. Just mentioning "in the playground" was enough for it to catch context. No need for elaborate shared plans.

**Screenshots:** Sending screenshots of console errors is still unreasonably effective.

**Planning mode:** I used it only when starting big chunks. Agent mode handled 95% of the work.

**The boundaries:** Cursor still isn't great with UI refinements - pixel-perfect alignment, using the right design tokens. That's where I take over.

## What Actually Changed

We've crossed a threshold. When everything from tiny fixes to complex refactors happens in seconds, not minutes:

- No context switching cost
- "Try it and see" becomes the default
- Experimentation is basically free
- You maintain your mental model throughout

This isn't about the 3x productivity gain. It's about AI becoming an extension of your thought process rather than an asynchronous collaborator. Above 20-30 seconds, you context switch. Below it, you stay in flow.

Maybe we're entering an era where we optimize for AI-readability like we did for human-readability. Where the boundary between human and AI code style dissolves. Where "good enough to maintain itself" becomes a new architectural principle.

The real question isn't whether AI makes us faster. It's what changes when the distinction between human and AI code becomes invisible.
